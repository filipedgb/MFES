class Track
/*
  Defines a sequence of blocks.
  FEUP, MFES, 2015/16.
*/
types
	
	
values
-- TODO Define values here
instance variables
	-- track is circular	
	private track: [seq of Block] := [];

operations
	/**
	 * Track constructor without blocks
	 *
	 * @param blocks 
	 * @return Train with auto-incremental id and the moving state set to the param value
	 */
	public Track : () ==> Track
	Track() == (
		return self
	);
	
	/**
	* Getter for the track
	* @return track
	*/
	public getTrack : () ==> seq of Block
	getTrack() == (
		return self.track
	);
	
	/**
	* Adds block to the track
	* @param block block to add
	*/
	public addBlockToTrack : Block ==> ()
	addBlockToTrack(block) == (
		track := track ^ [block];
		block.setIndexInTrack(len track)
	);
	
	public changeSemaphoresToRed : Train ==> ()
	changeSemaphoresToRed(t) == (
		dcl b: Block := t.getCurrentBlock();
		dcl index: nat := 0;
		
		if t.getDirection() then ( -- clockwise
			while	track(b.getIndexInTrack()+index).isStation() = false do (
				track(b.getIndexInTrack()+index).setSemaphore2(<RED>);
				index := index+1
			)
		) 
		else ( -- counterclockwise
			while	track(b.getIndexInTrack()-index).isStation() = false do (
				track(b.getIndexInTrack()-index).setSemaphore1(<RED>);
				index := index+1
			)
		)
	);
	
	/**
	* Moves train on block according to the direction and position of the train
	* @param t train
	*/
	-- falta ver os semaforos [n sei se vai ser para ver aqui]
	public moveTrain : Train ==> bool
	moveTrain(t) == (
		dcl b: Block := t.getCurrentBlock();
		if t.getDirection() then ( -- clockwise
			if b.getIndexInTrack() < len track then ( -- normal element
				if(t.getCurrentBlock().isStation()) then (
					if track(t.getCurrentBlock().getIndexInTrack()+2).getSemaphore1() = <RED> then (
						return false
					)
					else moveTrainConsequences(t,b,track(b.getIndexInTrack()+2));
					changeSemaphoresToRed(t)
				)
			  else (
			  	if track(t.getCurrentBlock().getIndexInTrack()+1).getSemaphore1() = <RED> then (
						return false
					)
			   	else moveTrainConsequences(t,b,track(b.getIndexInTrack()+1));
				);
				return true				
		  )
		  else ( -- was on last element of track, goes back to the beginning
				if track(1).getSemaphore1() = <RED> then (
					return false
				)
				else moveTrainConsequences(t,b,track(1));
				changeSemaphoresToRed(t);
				return true
		 	)
		)
		else ( -- counterclockwise
			if b.getIndexInTrack() = 1 then ( -- was on first element, goes to the end
				if track(len track).getSemaphore2() = <RED> then (
					return false
				) 
				else moveTrainConsequences(t,b,track(len track));
				return true
			) else ( -- normal element
				if(t.getCurrentBlock().isStation()) then (
					if track(b.getIndexInTrack()-2).getSemaphore2() = <RED> then (
						return false
					)
					else moveTrainConsequences(t,b,track(b.getIndexInTrack()-2));
					changeSemaphoresToRed(t)					
				)
			  else if track(b.getIndexInTrack()-1).getSemaphore2() = <RED> then (
					return false
				) 
			  else moveTrainConsequences(t,b,track(b.getIndexInTrack()-1));
			  return true
			)
		);
	);
	
public moveTrainConsequences : Train * Block * Block ==> ()
moveTrainConsequences(t,currentBlock,nextBlock) == (
	t.setCurrentBlock(nextBlock);
	nextBlock.setHasTrain(true);
	currentBlock.setHasTrain(false);
);

functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Track